"""Generate human-friendly markdown reports."""

from __future__ import annotations

from collections import defaultdict
from collections.abc import Iterable

from .models import AnalysisBundle, Feature, ModelDef


def build_markdown_report(bundle: AnalysisBundle) -> str:
    """Return the end-user facing synopsis in Markdown."""

    lines: list[str] = []
    lines.append("# Birdseye Project Guide")
    lines.append("")
    lines.append(
        "This guide explains what to run, what to expect, and how to follow up on the automatically discovered "
        "project features."
    )
    lines.append("")

    lines.extend(_overview_section(bundle))
    lines.extend(_workflow_diagram())
    lines.extend(_feature_walkthrough(bundle.features))
    lines.extend(_model_reference(bundle.models))
    lines.append("\n---\n")
    lines.append(
        "Generated by birdseye. Use this document to brief stakeholders or to seed scenario generation workflows."
    )

    return "\n".join(lines)


def _overview_section(bundle: AnalysisBundle) -> list[str]:
    feature_count = len(bundle.features)
    model_count = len(bundle.models)
    doc_count = len(bundle.documents)

    lines = ["## Quick Orientation", ""]
    lines.append("Follow the steps below to repeat this analysis on any repository:")
    lines.append("1. Run `birdseye analyze <input-path> <output-path>`.")
    lines.append("2. Wait for the scan to finish; it looks at source code and supporting markdown docs.")
    lines.append(
        "3. Open the generated `birdseye_overview.md` for human guidance and the JSON files for handoff to tooling."
    )
    lines.append("")
    lines.append(
        f"**What we found:** {feature_count} features, {model_count} data models, and {doc_count} documentation "
        "sections ready for cross-reference."
    )
    lines.append("")
    return lines


def _workflow_diagram() -> list[str]:
    return [
        "```mermaid",
        "flowchart TD",
        "    A[Choose project folder] --> B[Run birdseye scan]",
        "    B --> C[Feature JSON for LLM tooling]",
        "    B --> D[Human guide (this file)]",
        "    C --> E[Test generation or planning]",
        "    D --> E",
        "```",
        "",
    ]


def _feature_walkthrough(features: Iterable[Feature]) -> list[str]:
    grouped: defaultdict[str, list[Feature]] = defaultdict(list)
    for feature in features:
        grouped[feature.module_path].append(feature)

    lines = ["## Feature Walkthrough", ""]
    lines.append(
        "Each feature includes a short purpose, what to provide, and what should happen. Use the ID to trace it in "
        "JSON data."
    )
    lines.append("")

    for module, items in sorted(grouped.items()):
        lines.append(f"### Module: {module}")
        lines.append("")
        for feature in sorted(items, key=lambda feat: feat.feature_id or feat.name):
            lines.extend(_render_feature(feature))
        lines.append("")

    return lines


def _render_feature(feature: Feature) -> list[str]:
    lines: list[str] = []
    exposure_flags = _exposure_summary(feature)
    args_summary = ", ".join(f"{arg.name}: {arg.annotation or 'unknown'}" for arg in feature.args) or "None"
    returns_summary = feature.returns or "None"
    doc_note = f"Docs: {', '.join(feature.doc_refs)}" if feature.doc_refs else "Docs: none linked"

    lines.append(f"#### {feature.feature_id or '(untracked)'} · {feature.name}")
    lines.append(f"- **Kind:** {feature.kind} in `{feature.qualified_name}`")
    lines.append(f"- **Purpose:** {feature.short_doc()}")
    lines.append(f"- **Inputs:** {args_summary}")
    lines.append(f"- **Outputs:** {returns_summary}")
    lines.append(f"- **Exposure:** {exposure_flags}")
    lines.append(f"- **Quality:** complexity {feature.avg_complexity}, maintainability {feature.maintainability_index}")
    lines.append(f"- **References:** {doc_note}")
    lines.append("- **Try this:** " + "; ".join(_feature_examples(feature)))
    lines.append("")
    return lines


def _feature_examples(feature: Feature) -> list[str]:
    examples: list[str] = []
    if feature.cli:
        examples.append(f"Run the CLI command that triggers `{feature.name}` and capture the console output.")
        examples.append("List the required flags and what they influence.")
    if feature.api or feature.web:
        examples.append(f"Issue a sample request exercising `{feature.name}` and note the expected response fields.")
        examples.append("Record one happy-path payload and the expected status/result.")
    if feature.mcp:
        examples.append(f"Describe how an MCP client would call `{feature.name}` and what payload to expect.")
        examples.append("Note which MCP roles should see the result.")
    if not examples:
        examples.append(
            f"Call `{feature.name}` with typical inputs and describe the observable change or return value."
        )
        examples.append("Summarize the before/after state in one or two sentences.")
    return examples


def _exposure_summary(feature: Feature) -> str:
    flags = [
        label
        for label, active in (
            ("API", feature.api),
            ("CLI", feature.cli),
            ("MCP", feature.mcp),
            ("Web", feature.web),
            ("User facing", feature.user_facing),
        )
        if active
    ]
    return ", ".join(flags) if flags else "Internal"


def _model_reference(models: Iterable[ModelDef]) -> list[str]:
    lines = ["## Data Models", ""]
    models_list = list(models)
    if not models_list:
        lines.append("No structured models were detected.")
        lines.append("")
        return lines

    for model in sorted(models_list, key=lambda mdl: mdl.qualified_name):
        lines.append(f"### {model.name} ({model.qualified_name})")
        summary = model.docstring.strip() if model.docstring else "No description recorded."
        lines.append(f"{summary}")
        if model.fields:
            lines.append("| Field | Type | Default |")
            lines.append("|-------|------|---------|")
            for field in model.fields:
                default = field.default or "—"
                field_type = field.annotation or "unknown"
                lines.append(f"| {field.name} | {field_type} | {default} |")
        lines.append("")
    return lines
